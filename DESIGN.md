# RGBCTL
At a high level overview, *rgbctl* uses an animation loop to generate RGB data, which is then sent to one or more *drivers* to output the data to RGB devices.

A *driver* presents a fixed sized *frame buffer* for one or more zones to which it can output RGB data. This maybe a RGB strip of 4 LEDs on a Motherboard, or a 16 LED RGB ring of an AIO cooler. *rgbctl* will fill this frame buffer with colour data at a fixed-interval animation loop. This colour data is generated using *effects*, *shaders* and *textures*, much like a graphics pipeline. A *texture* contains a user-definable 2D array of colours. A *shader* can sample this *texture* data using RGB coordinate offset and effect time variables. An *effect* combines both a *texture* and a *shader*, along with the effect duration, into a single unit that generates all the RGB data needed for a single frame of a *driver*'s frame buffer.

*effects* can be configured to loop, play a one-shot animation, or even be sequenced one after another.

Overall, this design allows for almost infinite possibilities!

## Effects
RGB data is generated by *Effects*. An *Effect* comprises of an RGB *Texture* and a *Shader*. This terminology may be familiar to those with knowledge of computer graphics. *rgbctl* works in a very similar way; For each animation loop, a *Shader* is invoked with the coordinates of an RGB LED, a *Texture Unit*, and a real number value containing the current stage of the effect.

## Modules and Drivers
A *Module* advertises one or more *Drivers* to *rgbctl*. A *Driver* identifies which RGB device it can control via a vendor and product ID. The job of a *Driver* is to take a range of RGB triplets - 3 byte values in the range `0` - `255` - and format them into a packet or buffer that the end device will understand. The *Driver* will be asked to do this one or more times for each animation frame.

A *Driver* never communicates directly with a device itself. It reads and writes data through an API supplied by *rgbctl*, specifically the `rgbctl_read` and `rgbctl_write` functions. This design means that a *Driver* never has to concern itself with detecting and acquiring the low level communication channel of the underlying device. This is handled by *rgbctl* in the detection phase.

## Device Detection
*rgbctl* uses the *udev* subsystem to enumerate the available devices.
