# RGBCTL
At a high level overview, *rgbctl* uses an animation loop to generate RGB data, which is then sent to one or more *drivers* to output the data to RGB devices.

A *driver* presents a fixed sized *frame buffer* for one or more zones to which it can output RGB data. This maybe a RGB strip of 4 LEDs on a Motherboard, or a 16 LED RGB ring of an AIO cooler. *rgbctl* will fill this frame buffer with colour data at a fixed-interval animation loop. This colour data is generated using *effects*, *shaders* and *textures*, much like a graphics pipeline. A *texture* contains a user-definable 2D array of colours. A *shader* can sample this *texture* data using RGB coordinate offset and effect time variables. An *effect* combines both a *texture* and a *shader*, along with the effect duration, into a single unit that generates all the RGB data needed for a single frame of a *driver*'s frame buffer.

*effects* can be configured to loop, play a one-shot animation, or even be sequenced one after another.

Overall, this design allows for almost infinite possibilities!

## Effects
RGB data is generated by *Effects*. An *Effect* comprises of an RGB *Texture* and a *Shader*. This terminology may be familiar to those with knowledge of computer graphics. *rgbctl* works in a very similar way; For each animation loop, a *Shader* is invoked with the coordinates of an RGB LED, a *Texture Unit*, and a real number value containing the current stage of the effect.

## Modules and Drivers
A *Module* advertises one or more *Drivers* to *rgbctl*. A *Driver* identifies which RGB device it can control via a vendor and product ID. The job of a *Driver* is to take a range of RGB triplets - 3 byte values in the range `0` - `255` - and format them into a packet or buffer that the end device will understand. The *Driver* will be asked to do this one or more times for each animation frame.

A *Driver* never communicates directly with a device itself. It reads and writes data through an API supplied by *rgbctl*, specifically the `rgbctl_read` and `rgbctl_write` functions. This design means that a *Driver* never has to concern itself with detecting and acquiring the low level communication channel of the underlying device. This is handled by *rgbctl* in the detection phase.

## Device Detection
*rgbctl* uses the *udev* subsystem to enumerate the available devices.

## Effect Chains

### Sequence

```
[ Textures -> ] Shaders -> Targets
```

| Component     | Description                                                       |
|------------   |----------------                                                   |
| `Textures`    | Zero or more texture sources                                      |
| `Shaders`     | One or more shader programs. Can be chained or blended together   |
| `Targets`     | One or more targets. Output will be copied to all targets         |

`Textures` can be optional. This implies that the shader(s) will generate all the colour information.

### Effect Chain Format

```
Format:
    EFFECT_CHAIN : [ <TEXTURE_COMPONENTS> ' ' ] <SHADER_COMPONENTS> ' ' <TARGET_COMPONENTS>

    TEXTURE_COMPONENTS : <COMPONENT> [ ',' <COMPONENT> ]...

    SHADER_COMPONENTS : <COMPONENT> [ ( '+' | ',' ) <COMPONENT> ]...

    TARGET_COMPONENTS : <COMPONENT> [ ',' <COMPONENT> ]...

    COMPONENT : [ ( 'builtin' | 'user' ) ':' ] <NAME> [ ';' <ARG_NAME> [ '=' ( <ARG_VALUE> | 'true' | 'false' ) ] ]...

Notes:
    The component type prefix (`builtin:` or `user:`) is optional and `builtin:` is implied if
    not given. If a user-defined component is required then the `user:` prefix is necessary.

    Shader components can be "chained" by specifying two or more components separated by `,`.
    They can also be "blended" by specifying two or more components separated by `+`.

    Component arguments are optional, as are argument values. If only `ARG_NAME` is provided
    then the argument is equivalent to `ARG_NAME=true`.

Example:
    builtin:solid-color;r=255;g=0;b=0 rotate;dur=60+user:pulse-effect;interval=10 corsair-h100i,builtin:asus-x570;zone=0
```
