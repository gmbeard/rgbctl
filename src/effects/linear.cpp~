#include "rgbctl/effects/linear.hpp"

#include <cassert>
#include <cinttypes>
#include <cmath>

namespace rgbctl::effects
{

Linear::Linear(std::size_t rgb_count,
               std::size_t duration_ms,
               std::span<RgbFloat const> rgbs)
    : elapsed_ms_ { 0 }
    , rgb_count_ { rgb_count }
    , duration_ms_ { duration_ms }
    , points_ { rgbs.begin(), rgbs.end() }
{
    /* Ensure we've got the right amount of RGBs
     * in each frame...
     */
    assert(rgbs.size() % rgb_count == 0);
}

auto Linear::duration() const noexcept -> std::size_t { return duration_ms_; }

auto Linear::remaining() const noexcept -> std::size_t
{
    return static_cast<std::size_t>(duration_ms_ - elapsed_ms_);
}

auto Linear::tick(std::size_t ms, std::span<RgbUint8> out_frame)
    -> decltype(out_frame.begin())
{
    assert(out_frame.size() == rgb_count_);

    elapsed_ms_ += ms;
    if (elapsed_ms_ > duration_ms_)
        elapsed_ms_ %= duration_ms_;

    if (!points_.size() || !out_frame.size())
        return out_frame.begin();

    auto total_frame_count = points_.size() / rgb_count_;

    if (total_frame_count == 1) {
        return std::transform(
            points_.begin(),
            points_.end(),
            out_frame.begin(),
            [](auto const& rgb_float) { return to_rgb_uint8(rgb_float); });
    }

    float lerp_magnitude = 1 / static_cast<float>(total_frame_count - 1);

    float d =
        static_cast<float>(elapsed_ms_) / static_cast<float>(duration_ms_);

    auto current_frame = static_cast<std::ptrdiff_t>(
        d * static_cast<float>(total_frame_count - 1));

    auto start_pos =
        std::next(points_.begin(),
                  current_frame * static_cast<std::ptrdiff_t>(rgb_count_));

    auto next_frame_pos =
        std::next(start_pos, static_cast<std::ptrdiff_t>(rgb_count_));

    auto end_pos = next_frame_pos;

    // auto end_pos = std::next(start_pos);
    // if (end_pos == points_.end())
    //    end_pos = start_pos;

    d /= lerp_magnitude;

    auto out_pos = out_frame.begin();
    while (start_pos != end_pos && out_pos != out_frame.end()) {
        *out_pos = to_rgb_uint8(*start_pos + ((*next_frame_pos - *start_pos) *
                                              (d - std::floor(d))));

        ++start_pos;
        ++next_frame_pos;
    }

    return out_pos;
}

} // namespace rgbctl::effects
